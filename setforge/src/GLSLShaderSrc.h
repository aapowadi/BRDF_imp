#pragma once
/*

------------------------------------------------------------------------
Last edits:

July 4th, 2019, RR
- Added texture processing to image_renderer_vs and image_renderer_fs

*/


namespace glslshader
{

	static const string image_renderer_vs =
		"#version 410 core								\n"
		"												\n"		
		"uniform mat4 projectionMatrix;					\n"
		"uniform mat4 viewMatrix;						\n"
		"uniform mat4 modelMatrix;						\n"
		"												\n"
		"//uniform vec3 light_position;					\n"
		"uniform vec3 light_direction;					\n"
		"												\n"
		"in vec3 in_Position;							\n"
		"in vec3 in_Normal;								\n"
		"in vec2 in_Texture;							\n"				
		"												\n"
		"out vec3 pass_Normal;							\n"
		"out vec3 pass_Position;						\n"
		"out vec4 pass_Color;							\n"
		"out vec4 pass_Coordinates;						\n"
		"out vec2 pass_Texture;							\n"
		"												\n"
		"void main(void)								\n"
		"{												\n"
		"	// to calculate the real (linear) depth		\n"
		"	pass_Coordinates = projectionMatrix * viewMatrix * modelMatrix * vec4(in_Position, 1.0);	\n"
		"																								\n"
		"	// for lighting																				\n"
		"	pass_Position = vec3(viewMatrix *  modelMatrix  *  vec4(in_Position, 1.0));					\n"
		"																								\n"
		"	pass_Normal = vec3(transpose(inverse(viewMatrix * modelMatrix)) *  vec4(in_Normal, 0.0));	\n"
		"																								\n"
		"	pass_Color = vec4(normalize(in_Normal), 1.0);												\n"
		"																								\n"
		"	pass_Texture = in_Texture;																	\n"
		"																								\n"		
		"	// pass the position																		\n"
		"	gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(in_Position, 1.0);			\n"
		"																								\n"
		"	gl_PointSize = 4.0;																			\n"
		"}																								\n"
		"\n";

	static const string image_renderer_fs =
		"#version 410 core								\n"
		"												\n"		
		"#define MAX_LIGHTS 4							\n"	
		"												\n"	
		"uniform mat4 projectionMatrix;					\n"					                 
		"uniform mat4 viewMatrix;						\n"	                      
		"uniform mat4 modelMatrix;						\n"	
        "												\n"	
		"in vec3 pass_Normal;							\n"	
		"in vec3 pass_Position;							\n"	
		"in vec4 pass_Color;							\n"	
		"in vec4 pass_Coordinates;						\n"	
		"in vec2 pass_Texture;							\n"			
		"												\n"	
		"// The material parameters						\n"	
		"uniform struct LightSource {					\n"	
		"	vec3 position;								\n"	
		"	vec3 direction;								\n"	
		"	vec3 color;									\n"	
		"	float intensity;							\n"		
		"	float cutoff_in; // inner					\n"	
		"	float cutoff_out; // outer					\n"	
		"	float k1;    //attenuation					\n"	
		"	float k2;    //attenuation					\n"	
		"	bool used;									\n"	
		"	int  type;  //0:point, 1:spot, 2:directional\n"	
		"} light[MAX_LIGHTS];							\n"	
		"												\n"	
		"												\n"	
		"// The material parameters						\n"	
		"uniform struct Material {						\n"	
		"	vec3  diffColor;							\n"	
 		"	float diffInt;								\n"	
 		"	vec3  ambColor;								\n"	
 		"	float ambInt;								\n"	
 		"	vec3  specColor;							\n"	
 		"	float specInt;								\n"	
 		"	float shininess;							\n"	
		"} mat[1];										\n"	
		"												\n"	
		"uniform struct Textures {						\n"
		"	sampler2D tex_kd; // diffuse texture		\n"
		"	bool with_tex_kd; // default is false		\n"
		"	sampler2D tex_ka; // ambient texture		\n"
		"	bool with_tex_ka; //						\n"
		"	sampler2D tex_ks; // specular texture		\n"
		"	bool with_tex_ks;							\n"
		"	sampler2D tex_bump; // specular texture		\n"
		"	bool with_tex_bump; // bumpmap				\n"
		"	int tex_mode;  // 0: replace, 1: modulate, 2: decal, default = 1\n"
		"												\n"				
		"} tex[1];										\n"
		"												\n"
		"												\n"	
		"out vec4 color;								\n"	
		"												\n"	
		"/*												\n"	
		"Per-fragment light.							\n"	
		"Note that all vectors need to be in camera/eye-space.										\n"	
		"@param L - vector between light and fragment position.										\n"	
		"@param E - eye point																		\n"	
		"@param s - the light source																\n"	
		"@param m - the material																	\n"	
		"*/																							\n"	
		"vec4 useLight(vec3 L, vec3 E, vec3 N, LightSource s, Material m)							\n"	
		"{																							\n"	
		"	vec4 color = vec4(0.0,0.0,0.0,0.0);														\n"	
		"																							\n"	
		"	// diffuse light																		\n"	
		"	vec3 Idiff =  m.diffInt * m.diffColor *  max(dot(L, N), 0.0);							\n"	
		"	Idiff = clamp(Idiff, 0.0, 1.0);															\n"	
		"																							\n"	
		"	// ambient light																		\n"	
		"	vec4 Iamb = vec4( m.ambColor, 1.0) * m.ambInt;											\n"	
		"																							\n"	
		"	// specular light																		\n"	
		"	vec3 R = reflect(L, N);																	\n"	
		"	vec3 Ispec =  m.specInt * m.specColor *  pow(max(dot(R, E), 0.0), m.shininess);			\n"	
		"																							\n"	
		"	// calculate color																		\n"	
		"	color = max(vec4( ( Idiff + Ispec) * s.color, 1.0), Iamb)  * s.intensity;				\n"	
		"																							\n"	
		"	// attenuation																			\n"	
		"	float dist = length(L);																	\n"	
		"	float Iatt = 1 / (1 + s.k1 * dist + s.k2*s.k2 * dist);									\n"	
		"																							\n"	
		"	if(s.type == 0)//pointlight																\n"	
		"	{																						\n"	
		"		color = color * Iatt;																\n"	
		"	}																						\n"	
		"	else if(s.type == 1)// spotlight														\n"	
		"	{																						\n"	
		"		vec4 K = viewMatrix * vec4(normalize(s.direction - s.position), 0.0);				\n"	
		"		float a = dot(-L,K.xyz); // angle between light dir and fragment position.			\n"	
		"																							\n"		
		"		float c = smoothstep(1.0-s.cutoff_out, 1.0-s.cutoff_in, a);							\n"	
		"		Iatt = Iatt * c; // multiple with attenuation to maintain the distance effect.		\n"	
		"																							\n"	
		"		color = color * Iatt; // attenutation												\n"	
		"	}																						\n"	
		"																							\n"	
		"																							\n"	
		"	return color;																			\n"	
		"}																							\n"	
		"																							\n"	
		"																							\n"
		"/*																							\n"
		"Per-fragment light.																		\n"
		"Note that all vectors need to be in camera/eye-space.										\n"
		"@param L - vector between light and fragment position.										\n"
		"@param E - eye point																		\n"
		"@param s - the light source																\n"
		"@param m - the material																	\n"
		"@param tex_diff - diffuse texture color													\n"
		"@param tex_ambi - ambient texture color													\n"
		"@param tex_spec - specular texture color													\n"
		"*/																							\n"
		"vec4 useLightExt(vec3 L, vec3 E, vec3 N, LightSource s, Material m, vec4 tex_diff, vec4 tex_ambi, vec4 tex_spec, int tex_mode) \n"
		"{																							\n"
		"	vec4 color = vec4(0.0,0.0,0.0,0.0);														\n"
		"																							\n"
		"	// diffuse light																		\n"
		"	vec3 Idiff =  m.diffInt * m.diffColor *  max(dot(L, N), 0.0);							\n"
		"	Idiff = clamp(Idiff, 0.0, 1.0);															\n"
		"	Idiff = Idiff * tex_diff.rgb;															\n"
		"																							\n"
		"																							\n"
		"	// ambient light																		\n"
		"	vec4 Iamb = vec4( m.ambColor, 1.0) * m.ambInt;											\n"
		"	Iamb = Iamb * tex_ambi;																	\n"
		"																							\n"
		"	// specular light																		\n"
		"	vec3 R = reflect(L, N);																	\n"
		"	vec3 Ispec =  m.specInt * m.specColor *  pow(max(dot(R, E), 0.0), m.shininess);			\n"
		"	Ispec = Ispec * tex_spec.rgb;															\n"
		"																							\n"
		"  // blend mode																			\n"
		"	//tex_mode = 0;																			\n"
		"	if (tex_mode == 1){ // replace															\n"
		"		Idiff =  tex_diff.rgb;																\n"
		"		Iamb =  tex_diff;																	\n"
		"		Ispec = tex_spec.rgb;																\n"
		"	}																						\n"
		"																							\n"
		"	// calculate color																		\n"
		"	color = max(vec4( ( Idiff + Ispec) * s.color, 1.0), Iamb)  * s.intensity;				\n"
		"																							\n"
		"	// attenuation																			\n"
		"	float dist = length(L);																	\n"
		"	float Iatt = 1 / (1 + s.k1 * dist + s.k2*s.k2 * dist);									\n"
		"																							\n"
		"	if(s.type == 0)//pointlight																\n"
		"	{																						\n"
		"		color = color * Iatt;																\n"
		"	}																						\n"
		"	else if(s.type == 1)// spotlight														\n"
		"	{																						\n"
		"		vec4 K = viewMatrix * vec4(normalize(s.direction - s.position), 0.0);				\n"
		"		float a = dot(-L,K.xyz); // angle between light dir and fragment position.			\n"
		"																							\n"
		"		float c = smoothstep(1.0-s.cutoff_out, 1.0-s.cutoff_in, a);							\n"
		"		Iatt = Iatt * c; // multiple with attenuation to maintain the distance effect.		\n"
		"																							\n"
		"		color = color * Iatt; // attenutation												\n"
		"	}																						\n"
		"																							\n"
		"	return color;																			\n"
		"}																							\n"
		"																							\n"
		"																							\n"
		"																							\n"	
		"void main(void)																			\n"	
		"{																							\n"	
		"	// texture colors																		\n"	
		"	vec4 tex_kd_color = vec4(1,1,1,1);														\n"	
		"	if(tex[0].with_tex_kd) tex_kd_color = texture(tex[0].tex_kd, pass_Texture);				\n"	
		"																							\n"	
		"	// texture colors																		\n"	
		"	vec4 tex_ka_color = vec4(1,1,1,1);														\n"	
		"	if(tex[0].with_tex_ka) tex_ka_color = texture(tex[0].tex_ka, pass_Texture);				\n"	
		"																							\n"	
		"	// texture colors																		\n"	
		"	vec4 tex_ks_color = vec4(1,1,1,1);														\n"	
		"	if(tex[0].with_tex_ks) tex_ks_color = texture(tex[0].tex_ks, pass_Texture);				\n"	
		"																							\n"	
		"	// eye position																			\n"	
		"	vec3 E = normalize( vec3(viewMatrix[3][0], viewMatrix[3][1], viewMatrix[3][2]) );		\n"	
		"																							\n"	
		"																							\n"	
		"	// calc light.																			\n"	
		"	vec4 mixed = vec4(0.0,0.0,0.0,1.0);														\n"	
		"	for (int i=0; i<MAX_LIGHTS; i++){														\n"	
		"																							\n"	
		"		if(light[i].used == false) continue;												\n"	
		"																							\n"	
		"		// light position if camera frame													\n"	
		"		vec4 L_c = viewMatrix * vec4(light[i].position, 1.0);								\n"	
		"																							\n"	
		"		// light to fragment																\n"	
		"		vec3 L = normalize( L_c.xyz - pass_Position );										\n"	
		"		if(light[i].type == 2) L = light[i].direction;// direct light						\n"	
		"																							\n"	
		"		// checks whether the light was set.												\n"	
		"		// Multiple lights blend adative													\n"	
		"		mixed += useLightExt( L,  E,  pass_Normal, light[i], mat[0], tex_kd_color, tex_ka_color, tex_ks_color, tex[0].tex_mode);\n"	
		"																							\n"	
		"	}																						\n"	
		"																							\n"	
		"	color = mixed;																			\n"	
		"																							\n"	
		"																							\n"	
		"	//------------------------------------------------										\n"	
		"	// Get linear depth back																\n"	
		"																							\n"	
		"	// must match  the projection															\n"	
		"	const float n = 0.01; // camera z near													\n"	
		"	const float f = 10.0; // camera z far													\n"	
		"																							\n"	
		"	//   range without z/w -> [0, high value, linear but not scaled], with z/w -> range [-1,1]\n"	
		"	float current_depth = pass_Coordinates.z/ pass_Coordinates.w;							\n"	
		"																							\n"	
		"	// Adjust the range to [0,1]															\n"	
		"	//current_depth = 0.5 * current_depth + 0.5;  // range [0,1]							\n"	
		"																							\n"	
		"	// linear depth [0, depth]. requires range [-1, 1] as input.							\n"	
		"	// Calculate the real depth																\n"	
		"	current_depth  = (2.0 * f  * n) / (f + n - current_depth * (f - n)) ;					\n"	
		"																							\n"	
		"	gl_FragDepth =  current_depth;															\n"	
		"																							\n"	
		"																							\n"	
		"}\n";



		static string normal_renderer_vs =
			"#version 410 core																	\n"	           
			"																					\n"	
			"uniform mat4 projectionMatrix;														\n"	
			"uniform mat4 viewMatrix;															\n"	
			"uniform mat4 modelMatrix;															\n"	
			"																					\n"	
			"//uniform vec3 light_position;														\n"	
			"uniform vec3 light_direction;														\n"	
			"																					\n"	
			"in vec3 in_Position;																\n"	                                         
			"in vec3 in_Normal;																	\n"	
			"																					\n"	
			"out vec3 pass_Normal;																\n"	
			"out vec3 pass_Position;															\n"	
			"out vec4 pass_Color;																\n"	
			"out vec4 pass_Coordinates;															\n"	
			"																					\n"	
			"void main(void)																	\n"	
			"{																					\n"	
			"	// to calculate the real (linear) depth											\n"	
			"	pass_Coordinates =  projectionMatrix * viewMatrix * modelMatrix * vec4(in_Position, 1.0);		\n"	
			"																									\n"	
			"	// for lighting																					\n"	
			"	pass_Position = vec3(  viewMatrix *  modelMatrix  *  vec4(in_Position, 1.0));					\n"	
			"																									\n"	
			"	pass_Normal =   vec3( transpose(inverse(viewMatrix * modelMatrix)) *  vec4(in_Normal, 0.0));	\n"	
			"																									\n"	
			"	pass_Color = vec4(normalize(in_Normal), 1.0);													\n"	
			"																									\n"	
			"	// pass the position																			\n"	
			"	gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(in_Position, 1.0);				\n"	
			"																									\n"	
			"	gl_PointSize = 4.0;																				\n"	
			"}\n";

		static string normal_renderer_fs =
			"#version 410 core										\n"	
			"#define MAX_LIGHTS 4									\n"	
			"														\n"	
			"uniform mat4 projectionMatrix;							\n"	      
			"uniform mat4 viewMatrix;                               \n"	        
			"uniform mat4 modelMatrix;								\n"	
			"														\n"	
			"in vec3 pass_Normal;									\n"	
			"in vec3 pass_Position;									\n"	
			"in vec4 pass_Color;									\n"	
			"in vec4 pass_Coordinates;								\n"	
			"														\n"	
			"out vec4 color;										\n"	
			"														\n"	
			"void main(void)										\n"	      
			"{														\n"	
			"	color = vec4(pass_Normal, 0.0f);//pass_Color;		\n"	         
			"}\n";	

		static string display_renderer_vs =
			"#version 410 core										\n"
			"														\n"
			"uniform mat4 projectionMatrix;							\n"
			"uniform mat4 viewMatrix;								\n"
			"uniform mat4 modelMatrix;								\n"
			"														\n"
			"uniform float display_scale;							\n"
			"														\n"
			"in vec3 in_Position;									\n"
			"in vec3 in_Normal;										\n"
			"in vec2 in_Texture;									\n"
			"														\n"
			"out vec3 pass_Color;									\n"
			"out vec3 pass_Normal;									\n"
			"out vec2 pass_Texture;									\n"
			"														\n"
			"void main(void)										\n"
			"{																																	\n"
			"	gl_Position = vec4(in_Position, 1.0) * vec4(1.3, 1.3, 1.0, 1.0) -  vec4( display_scale * 0.6, display_scale * 0.7, 0.0, 0.0);	\n"
			"	pass_Normal = in_Normal.xyz;// vec3( transpose(inverse(modelMatrix))  * vec4(in_Normal, 0.0) );									\n"
			"	pass_Color = vec3(0.6, 0.6, 0.6);																								\n"
			"	pass_Texture = in_Texture;																										\n"
			"}\n";

		static string display_renderer_fs =
			"#version 410 core							\n"
			"											\n"
			"in vec3 pass_Color;						\n"
			"in vec2 pass_Texture;						\n"
			"in vec3 pass_Normal;						\n"
			"											\n"
			"uniform sampler2D tex;						\n"
			"											\n"
			"out vec4 color;							\n"
			"											\n"
			"void main(void)							\n"
			"{											\n"
			"	vec4 tex_color =  texture(tex, pass_Texture.xy);												\n"
			"																									\n"
			"	color = vec4(tex_color.x, tex_color.x, tex_color.x, 1.0) ; // + vec4(pass_Color, 1.0f) * 0.2;    \n"
			"																										\n"
			"	// Set the fragment depth to a small value to make sure that the object is always in front.		\n"
			"	gl_FragDepth = 0.000001;																			\n"
			"}   \n";
}